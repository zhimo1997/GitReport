1.提交时，git会记录索引的快照并把快照放进对象库，这个快照不包含该索引中任何文件或目录的副本，因为这样的策略需要巨大的存储空间。git会将当前索引的状态与之前的快照做一个比较，并派生出一个受影响的文件和目录列表。git会为任何有变化的文件创建新的blob对象，对有变化的目录创建一个新的树对象，对未改动的文件会沿用之前的blob对象和树对象。
提交的快照是串联在一起的，每张新的快照指向它的先驱。

2.将整个索引与之前某个状态的索引相比较的开销是比较大的，但整个过程是非常快的，原因：每个git对象都有一个散列值，如果两个对象甚至两个子树拥有相同的SHA1散列值，那么它们一定是相同的，就可以不用再比较。

3.提交是将变更引入版本库的唯一办法，任何版本库的变更都必须由一个提交引入。这项授权提供了问责制，任何情况下都不会出现版本库有数据变动而没有记录。对于提交不要有任何负担，git适合频繁提交。

4.原子变更集：每一个git提交都代表一个相对于之前的状态的单个原子变更集，对于一个提交中所有的改动，无论多少目录、文件、行、自己的改变，要么全部应用，要么全部拒绝。
git不关心文件为什么变化，即变更的内容不重要，git丝毫不在乎文件的语义。

5.查看旧提交
git log 回溯历史记录时，要注意git是依附于提交图的，而不是时间。
如果提供一个提交名，那么这个日志将从该提交开始回溯输出，这种形式的命令对于查看某个分支的历史记录是非常有用的。
git log --pretty=short --abbrev-commit --stat master~12..master~10
//格式选项：--pretty：调整显示的每个提交的信息数量，包括oneline,short,full等；--abbrev-commit：只是简单地请求缩写散列ID；
--stat：列举了提交中所更改的文件以及每个更改的文件中有多少行做了改动
